#!/bin/bash -e
set -o pipefail

# This is a copy of eos-write-live-image with everything related to the
# bootable Endless OS image removed, so it is only concerned with creating a
# data partition. It can be used as a drop-in replacement for eos-live-image
# in cases where one wishes to use the program without an actual OS image.

MOUNTS=/run/media/eos-write-live-image
EOSLIVE_MOUNTPOINT=$MOUNTS/eoslive


ARGS=$(getopt -o o:x:lp:r:nms:wL:fPS:e:h \
    -l windows-tool: \
    -l ntfs \
    -l label: \
    -l force \
    -l debug \
    -l extra-data: \
    -l help \
    -n "$0" -- "$@")
eval set -- "$ARGS"

NTFS=
MBR=
WINDOWS_TOOL_PROVIDED=
EXTRA_DATA_PATHS=()
FORCE=
LABEL=

usage() {
    local SELF
    SELF=$(basename "$0")
    cat <<EOF
Usage:
    $SELF [options] OUTPUT

Arguments:
    OUTPUT                   Device path (e.g. '/dev/sdb')

Options:
    -x, --windows-tool PATH  Path to Endless OS installer tool for Windows
    -L, --label LABEL        Autorun.inf label (default: Endless OS)
    -f, --force              don't ask to proceed before writing
    -e, --extra-data PATH    A local path to copy to the live partition, it can
                             be used multiple times
    -h, --help               Show this message

Developer options (you probably don't want to use these):
    -n, --ntfs               Format the image partition as NTFS, not exFAT
    -m, --mbr                Format DEVICE as MBR, not GPT
        --debug              Enable debugging output
EOF
}

function check_exists() {
    if [ ! -f "$1" ]; then
        echo "$2 $1 does not exist or is not a file" >&2
        exit 1
    fi
}

function cleanup_mountpoint() {
    if [ -d "$1" ]; then
        umount "$1" || :
        rmdir "$1"
    fi
}

function cleanup() {
    cleanup_mountpoint "$ISO_MOUNTPOINT"
    cleanup_mountpoint "$ESP_MOUNTPOINT"
    cleanup_mountpoint "$EOSLIVE_MOUNTPOINT"
    if [ -d "$MOUNTS" ]; then
        rmdir "$MOUNTS"
    fi
}

function find_by_type() {
    echo "$1" | grep -i "type=$2" | cut -d' ' -f1
}

while true; do
    case "$1" in
        -x|--windows-tool)
            shift
            WINDOWS_TOOL="$1"
            WINDOWS_TOOL_PROVIDED=true
            shift
            ;;
        -e|--extra-data)
            shift
            EXTRA_DATA_PATHS+=("$1")
            shift
            ;;
        -n|--ntfs)
            shift
            NTFS=true
            ;;
        -m|--mbr)
            shift
            MBR=true
            ;;
        -L|--label)
            shift
            LABEL="$1"
            shift
            ;;
        -f|--force)
            shift
            FORCE=true
            ;;
        --debug)
            shift
            set -x
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            break
            ;;
    esac
done

if [ $# -ne 1 ] ; then
    if [ $# -lt 1 ] ; then
        echo "Error: missing OUTPUT" >&2
    else
        echo "Error: extra arguments after OUTPUT:" "$@" >&2
    fi
    echo >&2
    usage >&2
    exit 1
fi

OUTPUT="$1"

USERID=$(id -u)
if [ "$USERID" != "0" ]; then
    echo "Program requires superuser privileges" >&2
    exit 1
fi

# Check for required tools
declare -A dependencies
dependencies=(
    [dd]='coreutils'
    [mkfs.vfat]='dosfstools'
    [partprobe]='parted'
    [sfdisk]='fdisk'
    [unzip]='unzip'
    [xzcat]='xz-utils'
    [zcat]='gzip'
)

if [ "$NTFS" ]; then
    MKFS_IMAGES="mkfs.ntfs"
    MKFS_ARGS='--quick -L'
    dependencies[$MKFS_IMAGES]='ntfs-3g'
else
    MKFS_IMAGES="mkfs.exfat"
    # By default, mkfs.exfat picks the cluster size (allocation unit) based on
    # the disk size.  On large disks this is 128 KiB, wasting a lot of space on
    # Endless Key with many small files.  Using 4 KiB (the default for very
    # small disks) appears to have some performance impact when reading large
    # files.  As a compromise, force the cluster size to 64 sectors, i.e. 32
    # KiB, which is the default for volumes between 256 MiB and 32 GiB.
    MKFS_ARGS='-s 64 -n'
    dependencies[$MKFS_IMAGES]='exfat-utils'
fi

if [ "$EXPAND" ]; then
    dependencies[truncate]='coreutils'
fi

missing_packages=()
for command in "${!dependencies[@]}"; do
    if ! command -v "$command" >/dev/null 2>&1; then
        echo "$command is not installed" >&2
        missing_packages+=("${dependencies[$command]}")
    fi
done
if [ ${#missing_packages[@]} -gt 0 ]; then
    echo "Try 'sudo apt-get install ${missing_packages[*]}'" >&2
    exit 1
fi

echo "Summary:"
echo
echo "  Installer for Windows: ${WINDOWS_TOOL:-latest release}"
echo "                 Target: ${OUTPUT}"
echo

if [ ! -e "$OUTPUT" ]; then
    echo "$OUTPUT does not exist... aborting!" >&2
    exit 1
fi

if [ ! -b "$OUTPUT" ]; then
    echo "$OUTPUT is not a block device... aborting!" >&2
    exit 1
fi

if grep -qs "$OUTPUT" /proc/mounts; then
    # Protect against overwriting the device currently in use
    echo "$OUTPUT is currently in use -- please unmount and try again" >&2
    exit 1
fi

if [ ! "$FORCE" ]; then
    read -r -p "Are you sure you want to overwrite all data on $OUTPUT? [y/N] "
    response="${REPLY,,}" # to lower
    if [[ ! "$response" =~ ^(yes|y)$ ]]; then
        exit 1
    fi
fi

if [ -z "$LABEL" ]; then
    LABEL="Endless OS"
fi

check_exists "$WINDOWS_TOOL" "Windows tool"

echo
echo "Preparing $OUTPUT..."

# Erase any existing ISO9660 (0x8000 == 8 * 4096) or Joliet
# (0x9000 == 9 * 4096) header on the disk. If you have written ISO image I
# to disk A, overwrite disk A with this tool, write I to disk B, then try
# to boot from B with A still plugged in, the "UUID" from the stale ISO9660
# header on A is still read by the kernel and taken as the UUID for disk A
# as a whole, and its BIOS boot partition too (for good measure). This
# confuses eos-image-boot-setup into trying to mount a partition on disk A
# rather than B.
dd if=/dev/zero of="$OUTPUT" bs=4096 count=2 seek=8
udevadm settle

if [ "$MBR" ]; then
    sfdisk --label dos "$OUTPUT" <<MBR_PARTITIONS
1 : type=7
MBR_PARTITIONS
    udevadm settle
    partprobe "$OUTPUT"
    PARTMAP=$(sfdisk --dump "$OUTPUT")
    DEVICE_IMAGES=$(find_by_type "$PARTMAP" "7")
else
    # https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
    PARTITION_BASIC_DATA_GUID="ebd0a0a2-b9e5-4433-87c0-68b6b72699c7"

    # We want the data partition, "eoslive", to occupy all the space on the disk
    # after the UEFI and BIOS boot partitions. But, we also want it to be numbered
    # first: apparently Windows will only mount the partition numbered first,
    # regardless of where it is on the disk.
    #
    # It is important that the offset of the BIOS boot partition matches that
    # used in the Endless OS image builder, since it is embedded in the GRUB
    # image.
    sfdisk --label gpt "$OUTPUT" <<EFI_PARTITIONS
1 : name=eoslive, type=$PARTITION_BASIC_DATA_GUID
EFI_PARTITIONS
    udevadm settle
    partprobe "$OUTPUT"
    PARTMAP=$(sfdisk --dump "$OUTPUT")
    DEVICE_IMAGES=$(find_by_type "$PARTMAP" "$PARTITION_BASIC_DATA_GUID")
fi

# Give udev a chance to notice the new partitions
udevadm settle

# Below here we start mounting stuff, so register a cleanup function
trap cleanup EXIT

$MKFS_IMAGES $MKFS_ARGS eoslive "${DEVICE_IMAGES}"
partprobe "$OUTPUT"
udevadm settle
mkdir -p "$EOSLIVE_MOUNTPOINT"
mount "$DEVICE_IMAGES" "$EOSLIVE_MOUNTPOINT"

echo

for EXTRA_DATA_PATH in "${EXTRA_DATA_PATHS[@]}"; do
    echo "Copying '$EXTRA_DATA_PATH'"
    cp -r "$EXTRA_DATA_PATH" "$EOSLIVE_MOUNTPOINT/"
done

if [ ! "$WRITABLE" ] || [ "$WINDOWS_TOOL_PROVIDED" ]; then
    echo "Copying Windows-specific files"

    cp "$WINDOWS_TOOL" "$EOSLIVE_MOUNTPOINT/"
    WINDOWS_TOOL_BASENAME="$(basename "$WINDOWS_TOOL")"
    sed 's/$/\r/' <<AUTORUN_INF | iconv -f utf-8 -t utf-16 > "$EOSLIVE_MOUNTPOINT/autorun.inf"
[AutoRun]
label=${LABEL}
icon=${WINDOWS_TOOL_BASENAME}
open=${WINDOWS_TOOL_BASENAME}

[Content]
MusicFiles=false
PictureFiles=false
VideoFiles=false
AUTORUN_INF
fi

echo
echo "Finalizing"

cleanup

udevadm settle
sync

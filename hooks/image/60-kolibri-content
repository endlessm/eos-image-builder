# Populate the Kolibri home directory

if [ -z "${EIB_KOLIBRI_INSTALL_CHANNELS}" &&
     -z "${EIB_KEY_INSTALL_CHANNELS}" ]; then
  exit 0
fi

# Use a separate content URL if configured.
if [ -n "${EIB_KOLIBRI_CENTRAL_CONTENT_BASE_URL}" ]; then
  KOLIBRI_CENTRAL_CONTENT_BASE_URL="${EIB_KOLIBRI_CENTRAL_CONTENT_BASE_URL}"
  export KOLIBRI_CENTRAL_CONTENT_BASE_URL
fi

# Do not create symlinks for static files inside the image builder.
export KOLIBRI_STATIC_USE_SYMLINKS=0

import_kolibri_channel()
{
  local app_name=$1
  local channel_id=$2
  local channel_include_node_ids_var="EIB_KOLIBRI_${channel_id^^}_INCLUDE_NODE_IDS"
  local channel_exclude_node_ids_var="EIB_KOLIBRI_${channel_id^^}_EXCLUDE_NODE_IDS"
  local importcontent_opts=(
    # Normally importcontent ignores download errors. Make it fail so we
    # can be sure we've fully provisioned channels.
    --fail-on-error
  )
  local importcontent_network_opts=(
    # The default timeout is 60 seconds, but downloading can be slow
    # when objects aren't in our content CDN yet.
    --timeout 300
  )

  if [ -n "${!channel_include_node_ids_var}" ]; then
    importcontent_include_nodes=$(echo "${!channel_include_node_ids_var}" | xargs | tr -s ' ' ',')
    importcontent_opts+=(--node_ids="${importcontent_include_nodes}")
  fi

  if [ -n "${!channel_exclude_node_ids_var}" ]; then
    importcontent_exclude_nodes=$(echo "${!channel_exclude_node_ids_var}" | xargs | tr -s ' ' ',')
    importcontent_opts+=(--exclude_node_ids="${importcontent_exclude_nodes}")
  fi

  kolibri manage importchannel network "${channel_id}"
  EIB_RETRY_ATTEMPTS=2 EIB_RETRY_INTERVAL=30 eib_retry \
    kolibri manage importcontent "${importcontent_opts[@]}" \
    network "${importcontent_network_opts[@]}" "${channel_id}"
}

prepare_kolibri_env()
{
  local app_name=$1
  # Needs to be kept in sync with hooks/image/61-kolibri-content-install
  KOLIBRI_CONTENT_DIR="${EIB_CONTENTDIR}/${app_name}-content"
  # FIXME: For now, we need to remove old content that may exist from previous
  # runs to prevent images accidentally getting extra channels that are not in
  # their configuration. However, this defeats the purpose of the image builder
  # saving the contents of EIB_CONTENTDIR between runs to improve its performance.
  # At some point we should revisit this to try to make the caching work properly.
  rm -rf "${KOLIBRI_CONTENT_DIR}"
  mkdir -p "${KOLIBRI_CONTENT_DIR}"

  venv_dir="${EIB_TMPDIR}/${app_name}-content-venv"
  python3 -m venv ${venv_dir}
  source ${venv_dir}/bin/activate

  pip install kolibri==${EIB_KOLIBRI_APP_VERSION}
  pip install kolibri-app-desktop-xdg-plugin==${EIB_KOLIBRI_APP_DESKTOP_XDG_PLUGIN_VERSION}
  pip install kolibri-desktop-auth-plugin==${EIB_KOLIBRI_DESKTOP_AUTH_PLUGIN_VERSION}

  export KOLIBRI_HOME="${KOLIBRI_CONTENT_DIR}"

  kolibri plugin enable kolibri.plugins.app
  kolibri plugin enable kolibri_app_desktop_xdg_plugin
  kolibri plugin enable kolibri_desktop_auth_plugin

  if [ ${app_name} == "kolibri" ]; then
    INSTALL_CHANNELS=("${KOLIBRI_INSTALL_CHANNELS[@]}")
  elif [ ${app_name} == "endless-key" ]; then
    INSTALL_CHANNELS=("${KEY_INSTALL_CHANNELS[@]}")
  else
    exit 1
  fi

  for channel_id in ${INSTALL_CHANNELS}; do
    import_kolibri_channel "${app_name}" "${channel_id}"
  done

  # Sort channels in the same order as in INSTALL_CHANNELS
  position=1
  for channel_id in ${INSTALL_CHANNELS}; do
    kolibri manage setchannelposition ${channel_id} ${position} || true
    let position=position+1
  done

  # Empty the user database, and ensure that each instance of this image has a
  # unique Facility ID.
  # <https://kolibri.readthedocs.io/en/latest/install/provision.html#prepare-the-kolibri-folder-for-copying>
  (echo yes; echo yes) | kolibri manage deprovision
}

if [ -n "${EIB_KOLIBRI_INSTALL_CHANNELS}" ]; then
  prepare_kolibri_env "kolibri"
fi

if [ -n "${EIB_KEY_INSTALL_CHANNELS}" ]; then
  prepare_kolibri_env "endless-key"
fi
